\documentclass{article}
\usepackage[utf8]{inputenc}

%% Useful packages
\usepackage{helvet}
\renewcommand{\familydefault}{\sfdefault}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{siunitx}
\usepackage[margin=1 in]{geometry}
\usepackage{indentfirst}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{url}

\colorlet{stringcolor}{purple}

\lstdefinestyle{baseStyle}{
  % display context
  rulesepcolor=\color{gray},
  aboveskip=3mm,
  belowskip=3mm,
  xleftmargin=1em,
  xrightmargin=2em,
  % the display itself
  basicstyle={\small\ttfamily},
  columns=flexible,
  showstringspaces=false,
  breaklines=true,
  breakatwhitespace=true,
  escapechar=|,
  % language-dependent highlighting settings
  keywordstyle=\color{blue},
  commentstyle=\color{teal},
  stringstyle=\color{stringcolor},
}

\lstdefinestyle{C++style}{
  style=baseStyle,
  language=C++
}

\lstdefinestyle{Rstyle}{
  style=baseStyle,
  language=R,
  %
  % Prevent highlighting of keywords that are substrings of
  % identifiers; see
  % https://tex.stackexchange.com/questions/318841/listings-with-r-keywords-in-variable-names-are-highlighted-when-using-underscor
  %
  otherkeywords={!,!=,~,$,*,\&,\%/\%,\%*\%,\%\%,<-,<<-,/},
  alsoother={.$}
}

\newcommand{\code}[1]{\lstinline[style=C++style]{#1}}
\newcommand{\Rcode}[1]{\lstinline[style=Rstyle]{#1}}

\lstnewenvironment{C++listing}[1][2]
{\lstset{
    style=C++style,
    gobble=#1
}}
{}

\lstnewenvironment{Rlisting}[1][2]
{\lstset{
    style=Rstyle,
    gobble=#1
}}
{}

% Shadow-box listings that are part of examples:
\lstnewenvironment{example}[1][2]
{\lstset{
    style=C++style,
    gobble=#1,
    frame=shadowbox
}}
{}

\lstnewenvironment{Rexample}[1][2]
{\lstset{
    style=Rstyle,
    gobble=#1,
    frame=shadowbox
}}
{}


\setlength{\parskip}{0.5 em}
\usepackage{tikz}
\usetikzlibrary{shapes.geometric, arrows, decorations.pathreplacing}

%%%%%%%%% This is for editing only. %%%%%%%%%%%%%
\usepackage[todonotes={textwidth=1.5in},commentmarkup=footnote]{changes} % I use footnotes for comments be cause the default margin comments are often trucated if they occur too close to the bottom of the page.
\setaddedmarkup{\textcolor{teal}{#1}}
\setdeletedmarkup{\textcolor{red}{#1}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newenvironment{descriptions}
  {\par\vspace{\abovedisplayskip}\begin{tabular}{>{$}r<{$} @{$:{}$} p{40em}}}
  {\end{tabular}\par\vspace{\belowdisplayskip}}

\newenvironment{newdescriptions}
  {\begin{tabular}{>{$}r<{$} @{$:{}$} l}}
  {\end{tabular}}


\newcommand{\placeholder}[1]{$\langle$\textrm{\textit{#1}}$\rangle$}
\newcommand{\stringplaceholder}[1]{{\color{stringcolor}"$\langle$\textrm{\textit{#1}}$\rangle$"}}

\newcommand{\boldX}{\mathbf{X}}

\newcommand{\cd}{\textsc{cd}}
% This makes TeX treat "cd" as a unit as opposed to typesetting it as
% the product of two variables "c" and "d".  Setting it in Roman font
% as well distinguishes it from a variable, which are be default set
% in italic font.  (If anything, it is a set of variables.)

\newcommand{\kn}{\textsc{k}} % for the collection of known variables
% The command \k is already taken.

\newcommand{\s}{\textsc{s}} % for the collection of derived variables

\newcommand{\g}{\mathbf{g}}
\newcommand{\h}{\mathbf{h}}

\newcommand{\isv}{\text{isv}}
\newcommand{\ip}{\text{ip}}
\newcommand{\vp}{\text{vp}}


\title{An Introduction to BioCro for Those Who Want to Add Models}
\author{Justin McGrath}

\begin{document}
\SweaveOpts{concordance=TRUE}
\maketitle
\section{Plant growth as a system of differential equations}
\subsection{Overview}

BioCro is used to calculate aspects of plant growth, such as the
change in the mass of a plant, given aspects of a plant and its
environment that are already known. For example, one can calculate
leaf and stem mass over thermal time given measures of the climate
(Figure \ref{fig:example}).

\begin{figure}[!h]
\centering
\includegraphics[width=0.3\textwidth]{an_introduction_to_biocro/example_gro.png}
\caption{\label{fig:example}Mass over time of willow.}
\end{figure}

BioCro is designed to reflect differential equation models. In this
section, we present some of the terminology and notation we will use
to describe such models.  Readers already familiar with such models
may want to skim though this section and then move on to section
\ref{sec:math_summary}.

We'll call the set of all of the variables in the model (mass,
temperature, wind speed, etc.) the \emph{state}. More precisely, a
\emph{state} is described by the set of values assumed by these
variables \emph{at some particular moment}.  We want to calculate a
sequence of states---a series of snapshots of the system being modelled
as it evolves over some period of time.  We'll denote the system
comprising these variables by $\boldX$ and the state of that system at
some specific time $t = t_i$ by $\boldX_{t_i}$.  (Here, $t_i$ denotes
the i'th instant of time (counting from 0) in some sequence $a = t_0 <
t_1 < t_2 < \dots < t_n = b$ of times, where $[a, b]$ is the time
interval of interest.)

Some parts of the state are taken as known for the entire period, and
we'll denote this component of the system as $\boldX_\kn$ ($\kn$ for
\underline{k}nown) and denote the known portion of the state at time
$t = t_i$ as $\boldX_{t_i,\kn}$. These values that are known
beforehand are inputs of the model, and in the literature, people
typically say that these variables ``drive" the model.

Some state variables can be calculated from other state variables
without explicit dependence on time. For example, the total mass of
the plant is the sum of leaf, stem, and root masses.  This set of
variables we'll denote as $\boldX_\s$ ({$\s$} for
\underline{s}econdary variable).\footnote{These were called ``steady
  state'' variables in a previous version of this document, and as of
  this writing, that terminology is still reflected in the BioCro
  software---both in the naming of variables and types of modules, and
  in the names of function parameters.  It was felt, however, that
  this was a somewhat confusing appropriation of a term that usually
  means ``unvarying over time''.  A possible alternative name was
  ``intermediate variable'', since a primary use of these variables is
  as convenience variables used in the calculating of derivatives.
  But they are also useful program output in their own right, so
  ``intermediate'' didn't seem entirely appropriate.}

Other variables must be calculated from their rate of change. For
example, the rate of change of leaf mass is calculated from the
photosynthetic rate, so the leaf mass at 10 a.m. is the leaf mass at 9
a.m. plus the rate of change in units of mass per hour times one hour;
that is, $\mathrm{mass}_\text{\,10\,\textsc{am}} =
\mathrm{mass}_\text{\,9\,\textsc{am}} + \frac{d\mathrm{mass}}{dt} *
\SI{1}{h}$.\footnote{Here, $\frac{d\mathrm{mass}}{dt}$ is the
  \emph{average} rate of change of mass over the period from 9 a.m. to
  10 a.m.  When using the forward Euler method, the derivative at the
  beginning of the time interval (at 9 a.m.) is taken as a reasonable
  approximation of this value.  Other numerical methods used by BioCro
  to estimate how the state changes are more complex, but all involve
  the equations giving the \emph{rate of change} of the variables in
  the state at a given time $t$ based on the \emph{value} of the
  variables in the state at time $t$.}\footnote{We have used time units of
  hours here, but it is a goal to eventually use only SI units within
  BioCro.  The SI base unit of time is the second, not the hour.} The
variables we calculate from rates of change we'll denote as
$\boldX_\cd$ ($\cd$ for \underline{c}alculated from
\underline{d}ifferential equations).


Analogously to writing $\boldX_{t_i}$ to denote the state of the
system $\boldX$ at time $t = t_i$, the ``$\cd$'' component of this
state will be denoted $\boldX_{t_i, \cd}$.  Since in general, each
$\boldX_{t_i, \cd}$ (for $i > 0$) depends on $\boldX_{t_{i-1}}$ (the
state at time $t_{i-1}$), an initial value $\boldX_{t_0, \cd}$ of the
$\cd$ component of the state must be given as input to the
model.\footnote{$\boldX_{t_0} = \boldX_{t_0, \kn} \cup \boldX_{t_0,
    \s} \cup \boldX_{t_0, \cd}$, but since $\boldX_{t_i, \kn}$ is
  assumed to be known for all times $t_i$ (including $t_0$) and since
  $\boldX_{t_0, \s}$ can be computed from $\boldX_{t_0, \kn} \cup
  \boldX_{t_0, \cd}$, the only remaining missing piece is
  $\boldX_{t_0, \cd}$.}

We'll denote the function that describes how to calculate secondary
variables ($\boldX_{t,\s}$) from the other variables as $\g$. Thus, at
any particular time $t_i$, $\boldX_{t_i,\s} = \g(\boldX_{t_i,\kn} \cup
\boldX_{t_i,\cd})$.\footnote{Denoting the set of known variables by
  $\kn$, the set of variables calculated from differential equations
  by $\cd$, and the \emph{number} of variables in $\kn$, $\cd$, and
  $\s$ by $|\kn|$, $|\cd|$, and $|\s|$ (respectively), then
  $\mathbf{g}$ is a vector-valued vector function from the
  ($|\kn|+|\cd|$)-dimensional Euclidean space whose axes are labelled
  by the variables of $\kn$ and $\cd$ to the $|\s|$-dimensional
  Euclidean space whose axes are labelled by the variables of $\s$.

  Alternatively, we can think of $\mathbf{g}$ as a collection of
  functions $\{g_v\,:\,v\in \s\}$ where each $g_v$ maps a collection
  of values for the variables in $\kn$ and $\cd$ to a value for the
  variable $v$.  These functions $g_v$ \emph{almost} correspond to
  what we currently call \emph{steady-state} modules in the BioCro
  software.  There are two ways in which they might differ, however.
  First, these modules may compute values for two or more variables
  rather than just one.  A module which calculates the values of
  variables $u$ and $v$, for example, would correspond to a function
  whose range has dimension two and which is defined by the rule
  $\mathbf{x}\mapsto(g_u(\mathbf{x}), g_v(\mathbf{x}))$.  The second
  way in which a module may differ from a function $g_v$ is that it
  may, for convenience, take as input previously-computed values of
  other variables in $\s$.  While in theory, each steady-state module
  could be restricted to use only variables in $\kn \cup \cd$ as
  input, in practice this would sometimes involve repetitious
  calculation.}  Note that, as this equation shows, $\boldX_{t_i,\s}$,
the ``$\s$'' component of the state at time $t_i$, depends only on the
values of the variables in the other components of the state at time
$t_i$.

As for the variables in the $\boldX_\cd$ component of $\boldX$, we can
calculate the value of their derivatives with respect to time---their
rate of change---at any particular time $t_i$ from some or all of the
variable values that comprise the totality of the state $\boldX$ at
time $t_i$.  We'll use $\h$ to denote the function that yields the
derivative of the $\boldX_\cd$ component of the state at any time
$t_i$ given the totality of the state at time $t_i$.  Thus,
$\frac{d\boldX_\cd}{dt}(t_i) = \h(\boldX(t_i))$\footnote{The
  right-hand side could be written as $\h(\boldX_{t_i})$; the two
  expressions $\boldX(t_i)$ and $\boldX_{t_i}$ essentially designate
  the same thing.  The connotations may be slightly different though.
  Using $\boldX(t_i)$ emphasizes that $\boldX$ is a state function,
  and when we write $\boldX(t_i)$, we are evaluating that function at
  time $t_i$. Writing $\boldX_{t_i}$ emphasizes that we are dealing
  with the state yielded by that evaluation.

For the left-hand side, another commonly used notation is
$\frac{d\boldX_\cd}{dt}{\Big\vert}_{t=t_i}$.}

The model can be solved by iterating through the following process for
each time point\ $t_i$ starting with time $t_0$:

\begin{enumerate}

\item Use the function $\g$ to calculate the value of the secondary
  variables at time $t_i$ from the values at time $t_i$ of the
  variables in $\kn$ and $\cd$.\footnote{Recall that values of the
    variables in $\cd$ are assumed to be known at time $t_0$.  For
    $i>0$, the values of the variables in $\cd$ at time $t_i$ are
    calculated in step 4 of the previous iteration.}
  
\item We now have full knowledge of the three components---the known
  variables, the secondary variables, and the variables that depend on
  differential equations---that comprise the full state $\boldX_{t_i}$
  at time $t_i$.

\item Use the function $\h$ to calculate the derivatives (rates of
  change) at time $t_i$ of the variables in $\boldX_\cd$.

\item Use the rates of change to calculate new values (that is, the
  values at time $t_{i+1}$) for the variables $\cd$ that depend on
  differential equations.

\end{enumerate}


This process is described somewhat more formally in the next section.

\subsection{Mathematical summary}
\label{sec:math_summary}

\subsubsection{Model inputs}
\label{sec:model_inputs}
The inputs to the model are the following:\footnote{Strictly speaking,
  it is probably more accurate to call only $\boldX_\kn$ and
  $\boldX_{0,\cd}$ \emph{inputs} to the model, and say that $\g$ and
  $\h$ \emph{define} the model.  Here, we are somewhat anticipating
  the terminology of the BioCro software where all four items are
  input parameters to a solver function that computes the output of
  the model.  (See section \ref{sec:solver_inputs}.)}

\begin{table}[!htbp]
  \begin{center}
    \begin{descriptions}

	  \boldX_\kn & The component of the system given as known for the
      entire simulation period. \\

	  \boldX_{0,\cd} & The initial values of those variables
      calculated using differential equations. \\

	  \g & A function for obtaining the values $\boldX_{t,\s}$ from
      those of $\boldX_{t,\kn}$ and $\boldX_{t,\cd}$ for any given
      time $t$. \\

	  \h & A function for obtaining the \emph{derivatives} of the
      variables in $\boldX_\cd$ from the values $\boldX_t$ for any
      given time $t$.

    \end{descriptions}
    \caption{\label{tab:model_inputs}Inputs to the model}
  \end{center}
\end{table}



\subsubsection{Model equations}
\label{sec:model_equations}
Whereas in the real world the state function $\boldX$ is a continuous
function of time on some time interval of interest $[t_0, t_n]$, in
practice we consider only the value of $\boldX$ for some finite
monotonically increasing sequence of points of time $t_0$, $t_1$,
$t_2$, \dots, $t_n$ within that interval.  This is both because the
so-called ``known'' variables are known only at some finite set of
instants in that interval and because it is a requirement of the
numerical methods used to solve the differential equations. The model
can be solved using Euler's method\footnote{Other generally better
  methods for solving systems are available in BioCro, but in the
  discussion here, we shall stick to Euler's method so as not to
  overly complicate the presentation.}  by iterating through the
following process for each $t=t_i$ starting at $t = t_0$:

\begin{align}
  \label{eq:solver_loop}
  \begin{split}
	\boldX_{t_i,\s} &= \g(\boldX_{t_i,\kn} \cup \boldX_{t_i,\cd}) \\
    \boldX_{t_i} &= \boldX_{t_i,\kn}  \cup \boldX_{t_i,\s} \cup \boldX_{t_i,\cd} \\
    \frac{d\boldX_\cd}{dt}(t_i) &= \h(\boldX(t_i))  \\
    \boldX_{t_{i+1},\cd} &= \boldX_{t_i,\cd} + \frac{d\boldX_{t_i,\cd}}{dt} \times \Delta t
  \end{split}
\end{align}

Here, $\Delta t = t_{i+1} - t_i$.  In general, it is assumed that the
instants $t_0$, $t_1$, $t_2$, \dots, $t_n$ are equally spaced so that $\Delta
t$ is of fixed size.



\subsection{Relating the mathematics to the program code}
\subsubsection{Function inputs}
\label{sec:solver_inputs}

The R function \code{Gro\_solver()} accepts five parameters that
correspond to the model inputs given in
Table~\ref{tab:model_inputs}. For convenience, $\boldX_\kn$ is
separated into variables that do or do not vary over the simulation
period.\footnote{The ``unvarying'' parameters are probably more
  properly viewed as parameters of the equations that make up $\g$ and
  $\h$ rather than being considered to be part of the $\boldX_\kn$
  component of the state function.  Some of them in fact are physical
  constants and so shouldn't be viewed as parameters at all and are
  only a part of the \emph{state} of the system in the most
  metaphysical of senses.  But in the programmatic implementation of
  the model, it proves useful to treat them as components of the
  state.}

\begin{table}[!htbp]
\begin{center}
\begin{tabular}{| r | l |}
	\hline
    \textbf{Gro\_solver() input} & \textbf{model equivalent} \\ 
    \hline
    \code{initial\_values} & $\boldX_{t_0,\cd}$ \\ 
    \code{parameters} & $\boldX_\kn$ that do not vary with time. \\ 
    \code{varying\_parameters} & $\boldX_\kn$ that do vary with time. \\ 
    \code{steady\_state\_module\_names} & $\g$ \\ 
    \code{derivative\_module\_names} & $\h$ \\
    \hline
\end{tabular}
\caption{\code{Gro\_solver}'s inputs}
\end{center}
\end{table}

State variables are represented as a paired name and value, for
example (``Leaf'', 10). In programming parlance, this is called a
key-value pair; here ``Leaf'' is the key and ``10" is the value.  In
R, the data types used to represent collections of such pairs are
\code{list} (more specifically, a \code{list} with named components)
and \code{data.frame}.\footnote{In the underlying C++ code, the
  corresponding structure is called a \emph{map}.  In mathematics,
  both ``map'' and ``function'' are used.  In our case, for example,
  the initial state $\boldX_{t_0}$ is a mapping from the set of
  variable names to their values at time $t_0$.} For example, if $\cd$
consists of a variable each for \emph{stem} and \emph{leaf} biomass,
then to specify initial values (that is, $\boldX_{t_0,\cd}$) one could
use the following:

\lstset{
  xleftmargin=0.05\textwidth, xrightmargin=0.2\textwidth
}

\begin{center}
  \begin{lstlisting}
    
# The list() function takes any number of key=value pairs, separated
# by commas.
> example_initial_values = list(Stem = 3, Leaf = 5)

# The str() function prints useful information about any object.
> str(example_initial_values)
List of 2
 $ Stem: num 3
 $ Leaf: num 5
 
# You can get a value using the key and the '$' operator ...
example_initial_values$Leaf
[1] 5

# ... or with the double-bracket operator '[[' operator and the
# string value of the key.
> example_initial_values[["Leaf"]]
[1] 5
> key_variable <- "Leaf"
> example_initial_values[[key_variable]]
[1] 5
\end{lstlisting}
\end{center}


Lists are also used to specify values for the \code{parameters}
argument.\footnote{The \code{Gro} function also uses an R \code{list}
  to specify the modules to be used.  The keys in this case are a
  fixed set of six module types, with the corresponding value naming
  an appropriate choice of module for the type specified.  The
  \code{Gro} function parses out the module names into two R
  \emph{character} vectors, one containing the names of
  ``steady-state'' modules, the other names of ``derivative'' modules.
  These are then passed to \code{Gro\_solver}.}

Lists of parameters and modules are provided for sorghum, miscanthus,
and willow and are named using names of the form
\emph{cropname}\code{\_initial\_state},
\emph{cropname}\code{\_parameters}, and
\emph{cropname}\code{\_modules};\footnote{Such a list of modules is
  intended to be used with the \code{Gro} function; see the previous
  footnote.} for example, \code{willow\_initial\_state}:

\begin{center}
\begin{lstlisting}
> str(head(willow_initial_state)) # head truncates the list to six items
List of 6
 $ Rhizome  : num 0.99
 $ Leaf     : num 0.02
 $ Stem     : num 0.99
 $ Root     : num 1
 $ Grain    : num 0
 $ waterCont: num 0.32
\end{lstlisting}
\end{center}

\code{varying\_parameters}, since it is made up of variables whose
value changes over the course of time, must be specified somewhat
differently.  In particular, the \emph{values} of the key-value pairs
comprising \code{varying\_parameters} will be vectors rather than
single values, and the number of elements in these vectors will
correspond to the number of time points $t_0$, $t_1$, $t_2$, \dots,
$t_n$ being sampled.  Moreover, in order to correlate the values in
these vectors to particular points of time, vectors specifying the
time must be included, and the time should be a
monotonically-increasing function of the vector index (in other words,
the time values should be in ``chronological order'').\footnote{As of
  this writing, the variable representing time that is most directly
  used in calculations is called \code{doy\_dbl}.  The integral
  portion of a \code{doy\_dbl} value represents the day-of-year (that
  is, 1 = January 1 and 365 = December 31 (or December 30 if it is a
  leap year)) and the fractional portion represents the hour of the
  day.  For example, 73.5 would represent 12-noon on the 73rd day of
  the year.  Note that this means that \code{doy\_dbl} represents the
  fractional number of days from the first instant of the new year
  \emph{plus one}.  In other words, the \code{doy\_dbl} values for
  January 1 run from 1.0 up to 2.0 rather than from 0 up to 1.0 so
  that 1.5 represents noon on January 1.  Also, no allowance is made
  for switching to daylight-savings time.

  The \code{doy\_dbl} variable may be provided by the user directly,
  but usually, the user will supply separate vectors \code{doy} (for
  day-of-year) and \code{hour}, and the \code{doy\_dbl} component of
  \code{varying\_parameters} will be computed and added by the
  software on the fly.

  Currently, the \code{year} component, if given, is for informational
  purposes only and does not figure in the computation of
  \code{doy\_dbl}.  This means that no provision is given for running
  systems with input data spanning multiple years except in a kind of
  hackish way involving supplying \code{doy\_dbl} directly and
  allowing values for it above 366.}

In the following example, the time is specified using vectors labelled
\emph{year}, \emph{doy} (``day-of-year''), and \emph{hour}.

\begin{center}
\begin{lstlisting}
> example_varying_parameters = data.frame(
            year = c(2005, 2005),
            doy = c(1, 1),
            hour = c(0, 1), 
            solar = c(0, 0),
            temp = c(4.04, 3.03))
> print(example_varying_parameters)

  year doy hour solar temp
1 2005   1    0     0 4.04
2 2005   1    1     0 3.03
\end{lstlisting}
\end{center}

Data frames of weather data are provided to pass to
\code{varying\_parameters}. These are typically for one year (January
1 to December 31) and should be subsetted to include only the period
of growth.  The function \code{get\_growing\_season\_climate()} is
provided as one means of subsetting climate data.\footnote{The
  \code{get\_growing\_season\_climate()} function requires its
  argument to have a \code{doy} component as well as a \code{temp}
  (temperature) component.}  Here is a display of weather data for
2005 showing the first few rows of the growing season:

\begin{center}
\begin{lstlisting}
> head(get_growing_season_climate(weather05))
     year doy hour solar    temp     rh windspeed precip
2953 2005 124    0     0  3.5972 0.3235    0.7603      0
2954 2005 124    1     0  1.3938 0.2496    0.7603      0
2955 2005 124    2     0 -0.2969 0.1928    0.7603      0
2956 2005 124    3     0 -1.3597 0.1572    0.7603      0
2957 2005 124    4     0 -1.7222 0.1450    0.7603      0
2958 2005 124    5     0 -1.3597 0.1572    0.7603      0
\end{lstlisting}
\end{center}

\subsubsection{Function output}
The output of \code{Gro\_solver} (and of \code{Gro}) is a data.frame,
which may be viewed as a table having one column for each variable in
\code{initial\_values} as well as columns for the time variables
\code{doy} (day of year), \code{hour}, and \code{doy\_dbl}.  (Other
columns may be included as well.)  The table has one row for each row
in \code{varying\_parameters}, that is, for each point of time for
which there is input data.

\begin{table}[!htbp]
\begin{center}
\begin{lstlisting}
     year doy hour    Stem   Root    Leaf
   1 2005   1    0   0.990   1.00   0.020
   2 2005   1    1   0.990   1.00   0.020
   3 2005   1    2   0.990   1.00   0.021
   4 2005   1    3   0.990   1.00   0.022
...
8759 2005 365   22  10.016   2.14   9e-08
8760 2005 365   23  10.016   2.14   9e-08
\end{lstlisting}
\caption{\label{tab:example_output} A truncated listing of the output used to produce Figure \ref{fig:example}}
\end{center}
\end{table}

\subsubsection{An example}
In R, you can use the \code{Gro()} function to simulate the
development of a crop as follows:

\begin{center}
\begin{lstlisting}
library(BioCro)
library(lattice)  # This is a package that creates figures.

result = Gro(sorghum_initial_state, sorghum_parameters,
             get_growing_season_climate(weather05), sorghum_modules)
xyplot(Stem + Leaf + Root ~ TTc, data=result)  # The output is not shown here.
\end{lstlisting}
\end{center}

\section{Modifying the BioCro code}
\subsection{Organization of the source files}
BioCro is provided as a package for R. The package subdirectories
containing the source code are \emph{R} for R code and \emph{src} for
C/C++ code.

To understand the organization of the code, it is necessary to know a
little about the data types in R and how the R environment accesses
compiled C/C++ code.

R provides C libraries that allow R code to call compiled code using C
data types specific to the R environment. Here, these libraries will
be called R-to-C libraries.\footnote{In despite of the appellation
  ``R-to-C'', keep in mind that data conversion happens in both
  directions: R input data types are converted to C data types to use
  as C/C++ function input.  The C data types returned by these
  functions are then converted to R data types suitable for R function
  output.} As an example, in R there is a \code{numeric} type that
represents real numbers.  The closest equivalent to this in C is the
\code{double} type.

As an example, we show how to write and compile a C function that
squares its argument and how to call that function from within R:

\begin{center}
\begin{lstlisting}[language=c,title=Contents of file \code{squarer.c}]
/* Rinternals.h contains the bulk of the R-to-C library definitions: */
#include <Rinternals.h>

SEXP my_function(SEXP x) {
    double new_x = REAL(x)[0];
    SEXP result;
    PROTECT(result = Rf_allocVector(REALSXP, 1));
    REAL(result)[0] = new_x * new_x;
    UNPROTECT(1);
    return result;
}
\end{lstlisting}
\end{center}

To compile this,\footnote{If this were to be compiled as a C++ program
  (as the BioCro source code is), one would have to wrap the
  \code{my\_function} definition with \code{extern "C" \{ ... \}}.}
one may then run
\begin{center}
\begin{lstlisting}
R CMD SHLIB squarer.c
\end{lstlisting}
\end{center}
This will produce the library file \code{squarer.so}.

Then to use this from R, open an R session and type the following commands:
\begin{center}
\begin{lstlisting}
> dyn.load("squarer.so") # make the C function available to R
> .Call("my_function", pi) # call my_function from R with argument pi
[1] 9.869604
\end{lstlisting}
\end{center}

The \code{SEXP} data type is provided by the R-to-C libraries and can
accommodate any of the data types used in the R environment (for
instance, numeric or character). The author of the C function must
know what data type is intended to be passed to the function. In this
example, the \code{REAL} macro is used to convert \code{x} to an array
of \code{double}s, and since there is only one element in the array,
the first index (\code{0})\footnote{Note that in R arrays begin with
  index 1 whereas C arrays begin with index 0.} is
accessed. \code{PROTECT()}, \code{UNPROTECT()}, and
\code{Rf\_allocVector()} are also required and are provided by the
R-to-C libraries, but understanding them is not necessary here.

Using the R-to-C libraries is tedious and error prone, and it is
extremely easy to write code that will run but produce hard-to-spot
errors.\footnote{A newer, purportedly better, R-C++ interface called
  Rcpp exists, but BioCro doesn't currently use it.} The use of the
R-to-C libraries should be limited, and they are not necessary at all
to add new models to BioCro. The libraries are described here only to
fully understand the organization of the code in the R package.

To sequester code that uses the R-to-C libraries, the code is
conceptually organized into three groups: R code, R-to-C code, and
C/C++ code. R code is in the \emph{R} directory. R-to-C code is
contained in files that have names that start with ``\code{R\_}'';
these files and the files containing C/C++ code are in the \emph{src}
directory.

The functions that define the model---the functions that make up the
vector-valued functions $\g$ and $\h$---and the code that iterates
through the the equations in equation set \ref{eq:solver_loop} to
solve the system being modelled are written in C++ and are thus
contained in files in the \emph{src} directory (or one of its
subdirectories). The functions that implement $\g$ and $\h$ should be
designed so that they do not rely on the R-to-C libraries in any
way. Such a design helps prevent mistakes from the error-prone R-to-C
libraries and allows the functions to be used without R---in a
stand-alone C++ application, for instance.


\begin{figure}[!ht]
\caption{\label{fig:code_organization} The R-to-C libraries provide an
  interface between R scripts and compiled code. The files are
  organized so that the R-to-C\ libraries are not mixed with the
  models. Model equations should only be written in the C/C++ code.}

\begin{center}
\begin{tikzpicture}[node distance=2 cm, decoration={brace}]
\tikzstyle{process} = [rectangle, minimum width=3 cm, minimum height=1 cm, text centered, draw=black, fill=orange!30]
\node (R)  [process, align=center] {\textbf{R files}\\R functions that\\call compiled C functions.};
\node (RC) [process, align=center, right of=R, xshift=4 cm] {\textbf{R-to-C files}\\C/C++ functions to convert between\\R and C/C++ objects and\\call the model functions.};
\node (C)  [process, align=center, right of=RC, xshift=4 cm] {\textbf{C/C++ files}\\C/C++ functions corresponding\\ to the model equations.};

\draw [latex-latex, line width=1.1 pt] (R) -- (RC);
\draw [latex-latex, line width=1.1 pt] (RC) -- (C);

\draw [decoration={brace, raise=10 pt, amplitude=12 pt}, decorate, line width=1 pt] (R.north west) -- node[above=23 pt] {Part of the R environment} (R.north -| RC.east);
\draw [decoration={brace, raise=10 pt, amplitude=12 pt, mirror}, decorate, line width=1 pt] (R.south -| RC.west) -- node[below=23 pt] {Compiled code} (RC.south -| C.east);
  
\end{tikzpicture}
\end{center}
\end{figure}

R code should be written so that it only checks validity of arguments
and calls R-to-C functions. R-to-C code should only provide error
checking and call C/C++ functions. That is, R and R-to-C functions
should only provide a way to access the models written in C/C++, and
no modeling should be done in R or R-to-C code.

\subsection[Adding new models]{Adding new models\footnotemark}


\footnotetext{Up until now, we have used the term \emph{model} to
  refer to the system as a whole, and the dynamics of how it changes
  over time.  Here we are using it in a more specialized sense: we
  \emph{model} the relationship between attributes of a state---how
  the values of some select group of attributes of the state determine
  the values or the rate of change of the values of other attributes
  of the state.  A model of the dynamics of soil evaporation, for
  instance, is a component of the model of the system as a whole.
  When we are being careful, we will use the term \emph{module} to
  refer to the code (or the C++ class) that implements a \emph{model}
  (in this more restricted sense), but at times, we may use the two
  terms interchangably.}

What follows are step-by-step instructions for writing modules and
integrating them into the BioCro library.  We show instructions both
for writing steady-state modules and for writing deriv modules.  In
each case, we include a running example; the actual code changes
needed are shown in shadowboxes at the end of each step.  (Full
listings of the finished code are given in the appendix.)

Following this, we show instructions for writing tests of the new
modules.

\subsubsection{Example: Steps for creating a steady-state module.}

Supose we want to write a module which builds upon the
\code{solar_zenith_angle} module.  That module, when given the
latitude (``lat'') and hour of the day (``hour'') as inputs, computes
the cosine of the solar zenith angle (``cosine\_zenith\_angle'').  We
would like to use the cosine of the solar zenith angle to calculate
the actual zenith angle in degrees.  So we shall write a module taking
one input---``cosine\_zenith\_angle''---to compute the value of the
angle itself.  The steps are as follows.

\begin{enumerate}

\item Decide on a name for the module.  While in theory, the name
  could be anything (ideally, something giving a concise description
  of the module), since we would like to follow the convention that
  the module name doubles as the name of the class that implements the
  module, the name (without quotes%
  \footnote{The quoted name is the ``public'' name: when you specify
    the module in a BioCro R function, or if you use the BioCro C++
    library in your own C++ code, it is the string name---the quoted
    name---that you use.}%
  ) should be a valid C++
  identifier.%
  \footnote{A valid C++ identifier must consist only of letters,
    digits and underscores; it can not begin with a digit nor match
    one of the C++ keywords.  Additionally, to avoid conflicting with
    names reserved by the implementation, it should not begin with an
    underscore, and it should not contain a sequence of two or more
    underscores or an underscore followed by a capital letter; in
    fact, for the sake of uniformity, it is preferable to avoid
    capital letters in module names altogether.  Although non-latin
    letters are allowed, it is best to avoid them so encoding of
    source files does not become an issue.}

  \begin{example}[4]
    "solar_zenith_angle_in_degrees"
  \end{example}

\item Make a new file called \placeholder{module name}\code{.h} in the
  \code{src/module_library} directory.%
  \footnote{Here, and in what follows, we use italicized descriptors
    in angle brackets as placeholders for actual names or parts of
    names of files or variables.  So, for example, if we have chosen
    ``solar\_zenith\_angle\_in\_degrees'' as the module name, then
    \placeholder{module name}\code{.h} designates
    \code{solar_zenith_angle_in_degrees.h}, the name we get by
    substituting \code{solar_zenith_angle_in_degrees} for
    \placeholder{module name}.  Again, using the module name to form
    the file name is by convention, but a useful one if one is trying
    to find the code that implements a model.}

  \begin{example}[4]
    solar_zenith_angle_in_degrees.h
  \end{example}

\item Add appropriate header guards to the file.
  \begin{example}[4]
    #ifndef SOLAR_ZENITH_ANGLE_IN_DEGREES_H
    #define SOLAR_ZENITH_ANGLE_IN_DEGREES_H
    ...
    #endif
  \end{example}

\item Add include directives to include the module base class
  declarations from \code{modules.h} and the type aliases from
  \code{state_map.h}.
  \begin{example}[4]
    #include "../modules.h"
    #include "../state_map.h''
  \end{example}

\item Begin a declaration of a class for the module, deriving it from
  SteadyModule.  The identifier used for the class name should match
  the module name you decided upon in step 1.\footnotemark
    \footnotetext{Here again, matching the class name to the module name
    is a convention.  It won't break anything if you don't except
    perhaps the expectations of readers of your code.}
    Include a Doxygen-style comment (that is, starting with
    \code{/**}) describing the module and its purpose immediately
    above the class declaration.  The first sentence should be a brief
    summary of the module.  This is followed by additional details or
    a fuller description.  This is an appropriate place to include
    citations to sources for equations used by the module in
    calculations, the reasoning and justification for the model, and
    information to help the user determine when use of the model is
    appropriate.\footnotemark%

    \footnotetext{The code that actually \emph{uses} the said
      equations will most likely be in the body of the
      \code{do_operation} function (or in some subsidiary function
      called by it).  But \code{do_operation} is a private function,
      so it is more appropriate to put ``public'' information here.
      Documentation of \code{do_operation}, if any, should mostly be
      about programming details.}
  \begin{example}[4]
    /**
     *  Given a value for the BioCro variable "cosine_zenith_angle",
     *  compute and output a value for the variable
     *  "zenith_angle_in_degrees" that corresponds to the angle having
     *  the given cosine.
     *
     *  The module allows negative cosine values, corresponding to
     *  positions of the sun below the horizon.  If out-of-range values
     *  for the cosine are given, the output variable is set to NaN
     *  ("not-a-number").
     */

    class solar_zenith_angle_in_degrees : public SteadyModule {
      ...
      ...
      ...
    }
  \end{example}

\item Inside the body of the class declaration, declare private data
  members for pointers to each input parameter and each output
  parameter.  Input parameter pointers should be of type \code{const
    double*}; by convention, they should have names of the form
  \placeholder{parameter name}\code{_ip},
  where \placeholder{parameter name} is the name of
  the corresponding parameter.%
  \footnote{There has been some discussion of relaxing this
    convention: As with module names, the (quoted) parameter name is
    the ``public-facing'' name known to users of the BioCro R
    functions or the BioCro C++ library.  As such, it might be
    desirable to be able to use more natural-sounding and descriptive
    names (and be able to include spaces!) rather than being confined
    to only using names the can be used in a C++ identifier.  In other
    words, it would be nice if these parameter names were
    ``user-centric'' instead of ``programmer-centric'': it is more
    user-centric, for example, to output simulation results with a
    column names like ``Relative Humidity'' and ``Temperature'' rather
    than ``rh'' and ``temp''.  (Your users will know without thinking
    that you aren't talking about blood types and temporary workers!)
    There may, however, be other better ways of addressing this
    issue.}
  Output parameter pointers should be of type \code{double*} and
  should have names of the form \placeholder{parameter
    name}\code{_op}.\footnote{Be sure to consult the master parameter
    list to ensure you are using the input and output parameters
    correctly---that you are not assigning new meanings to existing
    parameters, and that the units you are expecting as input and that
    you wish to see in output match the units designated in that list.
    \emph{If you are using a parameter whose name is not in that list,
      you will have to add it.}}
  \begin{example}[4]
    private:
       // Pointers to input parameters:
       const double* cosine_zenith_angle_ip;

       // Pointers to output parameters:
       double* zenith_angle_in_degrees_op;
  \end{example}

\item Declare a public constructor with signature \placeholder{class
  name}\code{(const state_map* input_parameters, state_map*
  output_parameters)}.  The constructor needs to initialize the base
  class \code{SteadyModule} with the name for the module, and each
  parameter pointer needs to be initialized with an initializer of the
  form
  \begin{C++listing}[4]
    |\placeholder{parameter name}|_ip{get_ip(input_parameters, |\stringplaceholder{parameter name}|)}
  \end{C++listing}
  (for input parameters), or
  \begin{C++listing}[4]
    |\placeholder{parameter name}|_op{get_op(output_parameters, |\stringplaceholder{parameter name}|)}
  \end{C++listing}
  (for output parameters).

  \begin{example}[4]
    public:
       solar_zenith_angle_in_degrees(
           const state_map* input_parameters,
           state_map* output_parameters
       )
           : SteadyModule{"solar_zenith_angle_in_degrees"},
           cosine_zenith_angle_ip{get_ip(input_parameters, "cosine_zenith_angle")},
           zenith_angle_in_degrees_op{get_op(output_parameters, "zenith_angle_in_degrees")}
           {}
  \end{example}

\item Add the following static function declarations to the public
  section of the class body.
  \begin{example}[4]
    static std::vector<std::string> get_inputs();
    static std::vector<std::string> get_outputs();
    static std::string get_description();
  \end{example}

\item Add the following declaration to the private section to override
  the corresponding virtual function in the base class.
  \begin{example}[4]
    // Implement the pure virtual function do_operation():
    void do_operation() const override final;
  \end{example}

\item Implement \code{get_inputs()}; the function should return a
  vector of the names of all of the input parameters.  The function
  body can be just a return statement with the returned value written
  in the form of a \{\}-list, that is, a list of quoted strings of
  input parameter names, separated by commas and surrounded by curly
  braces.

  \begin{example}[4]
    std::vector<std::string> solar_zenith_angle_in_degrees::get_inputs() {
        return {
            "cosine_zenith_angle"
        };
    }
  \end{example}

\item Implement \code{get_outputs()} similarly, returning a list of
  the names of all output parameters.
  \begin{example}[4]
    std::vector<std::string> solar_zenith_angle_in_degrees::get_outputs() {
        return {
            "zenith_angle_in_degrees"
        };
    }
  \end{example}

\item Implement the \code{get_description()} function.

\item Implement the \code{do_operation()} function.  This is the heart
  of the module---it's where the real work gets done.  Generally, the
  body of this function should contain a statement of the form
  \begin{C++listing}[4]
    update(|\placeholder{output parameter}|_op,|\placeholder{some value}|);
  \end{C++listing}
  for each output parameter.  Here, \placeholder{some value} is some
  numerical value calculated in the body of the function prior to the
  update statement, and it will generally be calculated from the
  dereferenced values of the input parameter pointers.  Computations
  often may entail the use of additional include directives, for
  example \code{\#include <cmath>} or \code{\#include
    "../constants.h"}.  In our example, the function definition (along
  with the required extra include directives) looks like this:
  \begin{example}[4]
    ...
    ...
    #include <cmath> // for acos
    #include "../constants.h" // for pi
    ...
    ...
    void solar_zenith_angle_in_degrees::do_operation() const {
        double zenith_angle { acos(*cosine_zenith_angle_ip)
                              * 180 / math_constants::pi };
        update(zenith_angle_in_degrees_op, zenith_angle);
    }
  \end{example}

\end{enumerate}

A listing of the completed module code is shown in appendix \ref{sza
  module listing}.

Once the new module has been written, it must be integrated into the
rest of the BioCro code.  This involves modifying the file
\code{module_library/module_wrapper_factory.cpp} and requires two
steps:

\begin{enumerate}

\item Add an include directive to include the header file for the new module.
  \begin{example}[4]
    #include "solar_zenith_angle_in_degrees.h"
  \end{example}

\item Add an entry to
  \code{module_wrapper_factory::module_wrapper_creators}.  This
  will be a bracketed pair of the form
  \begin{C++listing}[4]
    {|\stringplaceholder{module name}|, &create_wrapper<|\placeholder{module name}|>}
  \end{C++listing}

  \begin{example}[4]
    {"solar_zenith_angle_in_degrees", &create_wrapper<solar_zenith_angle_in_degrees>}
  \end{example}

\end{enumerate}

\subsubsection{Example: Steps for creating a derivative module.}

Supose that we have weather data giving the ambient temperature over
some period of time and we wish write a module to help us calculate
the (cumulative) number of heating degree days over that same period.
This is essentially the integral of the amount the ambient temperature
falls short of some ``threshold'' or ``base'' temperature, but
counting negative amounts as zero.  For this example, we will assume
that the ambient temperature is given in a variable called ``temp''
and the base temperature variable is named ``base\_temperature''.
These will be varying and unvarying known variables, respectively.

The steps for writing such a module are similar to those for writing a
steady-state module, but with some significant differences.

\begin{enumerate}

\item Decide on a name for the module.

  \begin{example}[4]
    "heating_degree_days"
  \end{example}

\item Make a new file called \placeholder{module name}.h in the
  \code{src/module_library} directory.

  \begin{example}[4]
    heating_degree_days.h
  \end{example}

\item Add appropriate header guards to the file.
  \begin{example}[4]
    #ifndef HEATING_DEGREE_DAYS_H
    #define HEATING_DEGREE_DAYS_H
    ...
    ...
    ...
    #endif
  \end{example}

\item Add include directives to include the module base class
  declarations from \code{modules.h} and the type aliases from
  \code{state_map.h}.
  \begin{example}[4]
    #include "../modules.h"
    #include "../state_map.h''
  \end{example}

\item Begin a declaration of a class for the module, deriving it from
  DerivModule.  The identifier used for the class name should match
  the module name you decided upon in step 1.
  \begin{example}[4]
    class heating_degree_days : public DerivModule {
      ...
      ...
      ...
    }
  \end{example}

\item Declare private data members for pointers to each input
  parameter and each output parameter.  Just as with steady-state
  modules, input parameter pointers should be of type \code{const
    double*} and by convention should have names of the form
  \placeholder{parameter name}\code{_ip}, where \placeholder{parameter
    name}{} is the name of the corresponding parameter.  Output
  parameter pointers should be of type \code{double*} and should have
  names of the form \placeholder{parameter name}\code{_op}.
  \begin{example}[4]
    private:
       // Pointers to input parameters:
       const double* temp_ip;
       const double* base_temperature_ip;

       // Pointers to output parameters:
       double* heating_degree_days_op;
  \end{example}

\item Declare a public constructor with signature \placeholder{class
  name}\code{(const state_map* input_parameters, state_map*
  output_parameters)}.  The constructor needs to initialize the base
  class \code{DerivModule} with the name for the module, and each
  parameter pointer needs to be initialized with an initializer of the
  form
  \begin{C++listing}[4]
    |\placeholder{parameter name}|_ip{get_ip(input_parameters, |\stringplaceholder{parameter name}|)}
  \end{C++listing}
  (for input parameters), or
  \begin{C++listing}[4]
    |\placeholder{parameter name}|_op{get_op(output_parameters, |\stringplaceholder{parameter name}|)}
  \end{C++listing}
  (for output parameters).

  \begin{example}[4]
    public:
       heating_degree_days(
           const state_map*
               input_parameters,
           state_map*
               output_parameters
       )
       : DerivModule{"heating_degree_days"},
         temp_ip{get_ip(input_parameters, "temp")},
         base_temperature_ip{get_ip(input_parameters, "base_temperature")},
         heating_degree_days_op{get_op(output_parameters, "heating_degree_days")}
       {}
  \end{example}

\item Add the following static function declarations to the public
  section of the class body.
  \begin{example}[4]
    static std::vector<std::string> get_inputs();
    static std::vector<std::string> get_outputs();
    static std::string get_description();
  \end{example}

\item Add the following declaration to the private section to override
  the corresponding virtual function in the base class.
  \begin{example}[4]
    // Implement the pure virtual function do_operation():
    void do_operation() const override final;
  \end{example}

\item Implement \code{get_inputs()}; the function should return a
  vector of the names of all of the input parameters.  The function
  body can be just a return statement with the returned value written
  in the form of a \{\}-list, that is, a list of quoted strings of
  input parameter names, separated by commas and surrounded by curly
  braces.

  \begin{example}[4]
    std::vector<std::string> heating_degree_days::get_inputs() {
        return {
            "temp",
            "base_temperature"
        };
    }
  \end{example}

\item Implement \code{get_outputs()} similarly, returning a list of
  the names of all output parameters.
  \begin{example}[4]
    std::vector<std::string> heating_degree_days::get_outputs() {
        return {
            "heating_degree_days"
        };
    }
  \end{example}

\item Implement the \code{get_description()} function.

\item Implement the \code{do_operation()} function.  This is the heart
  of the module---it's where the real work gets done.  Generally, the
  body of this function should contain a statement of the form
  \begin{C++listing}[4]
    update(|\placeholder{output parameter}|_op,|\placeholder{some value}|);
  \end{C++listing}
  for each output parameter.  Here, \placeholder{some value} is some
  numerical value calculated in the body of the function prior to the
  update statement, and it will generally be calculated from the
  dereferenced values of the input parameter pointers.  Since this is
  a \emph{derivative} module, it represents the \emph{rate of change
    \textbf{per hour}} of the output parameter.

  Computations
  often may entail the use of additional include directives, for
  example \code{\#include <cmath>} or \code{\#include
    "../constants.h"}.

  In our example, the function definition looks like this:
  \begin{example}[4]
    void heating_degree_days::do_operation() const {
        double temperature_deficit {
          *base_temperature_ip > *temp_ip ?
          (*base_temperature_ip - *temp_ip) : 0
        };

        update(heating_degree_days_op, temperature_deficit / 24.0);|\footnotemark|
    }
  \end{example}

  \footnotetext{We must divide by 24 here because we want the rate of
    change of heating degree days \emph{per hour}.}

\end{enumerate}

A listing of the completed module code is shown in appendix \ref{hdd
  module listing}.

The steps for integrating the module into the rest of the BioCro code
are exactly the same as for steady state modules, again only requiring
a few modifications to
\code{module_library/module_wrapper_factory.cpp}:

\begin{enumerate}

\item Add an include directive to include the header file for the new module.
  \begin{example}[4]
    #include "heating_degree_days.h"
  \end{example}

\item Add an entry to
  \code{module_wrapper_factory::module_wrapper_creators}.  This
  will be a bracketed pair of the form
  \begin{C++listing}[4]
    {|\stringplaceholder{module name}|, &create_wrapper<|\placeholder{module name}|>}
  \end{C++listing}
  \begin{example}[4]
    {"heating_degree_days", &create_wrapper<heating_degree_days>}
  \end{example}

\end{enumerate}


\subsection{Writing tests for new models}

Once a new module has been written, a set of unit tests should be
written to ensure that it works as expected.  For more about unit
tests in R, see \url{https://r-pkgs.org/tests.html}.  For general,
non-language-specific discussions of unit testing, see
\url{https://martinfowler.com/bliki/UnitTest.html} or
\url{https://builtin.com/software-engineering-perspectives/what-is-unit-testing}.


Here are step-by-step instructions for writing unit tests of modules,
using as examples the modules we have just written.\footnote{These
  instructions are for testing in R.  It would be much more direct to
  use a C++ testing framework to test C++ code; presumably such tests
  could test the module functions independently of the rest of the
  BioCro code, with a minimum of set-up and tear-down code.  But
  writing tests in R is simpler.  Note, though, that this way of
  testing modules depends on the correct functioning of the R
  framework for running BioCro simulations.  If the framework is
  buggy, then the module tests may fail for reasons not having
  anything to do with the module itself.}

\subsubsection{Writing a unit test for a steady-state module}

For testing a steady-state module, it will suffice to set up a
bare-bones system: the sequence of states can be a sequence of length
one since we aren't interested in how the state changes over time.
And the state variables need only include the input variables for the
module being tested plus certain time-related variables.

\begin{enumerate}

\item Create a file for the module tests in the directory
  \code{tests/testthat}.  The file name should begin with ``test'' and
  end with ``.R''.  A good name for the file would be something of the
  form \code{test.}\placeholder{module name}\code{.R}.

  \begin{example}[4]
    test.solar_zenith_angle_in_degrees.R
  \end{example}

\item At the top of the new file, add a \emph{context} statement
  providing a general description of the tests in the file.  This
  will be a statement of the form
  \Rcode{context(}\stringplaceholder{some descriptive text}\Rcode{)}.

  \begin{Rexample}[4]
    context('Test basic functioning of the steady-state module "solar_zenith_angle_in_degrees".')
  \end{Rexample}

\item Define parameters for the \Rcode{Gro_solver} function.  Assuming
  we call \Rcode{Gro_solver} as
  \begin{Rlisting}[4]
    Gro_solver(initial_state, invariant_parameters, varying_parameters,
               steady_state_modules, derivative_modules, solver, verbose)
  \end{Rlisting}
  we have seven variables we need to define:
  \begin{Rlisting}[4]
    initial_state <- ...
    invariant_parameters <- ...
    varying_parameters <- ...
    steady_state_modules <- ...
    derivative_modules <- ...
    solver <- ...
    verbose <- ...
  \end{Rlisting}

  (The last two have default values of
  \begin{Rlisting}[4]
    list(type='Gro', output_step_size=1.0, adaptive_rel_error_tol=1e-4, adaptive_abs_error_tole=1e-4, adaptive_max_steps=200)
  \end{Rlisting}
  and \Rcode{FALSE}, respectively.  Since it doesn't matter what
  solver we use for testing a steady state module, and since in
  general tests shouldn't produce their own output, these are suitable
  values and may be omitted.\footnotemark)

  \footnotetext{There may be cases where we may want to temporarily
    set \Rcode{verbose} to \Rcode{TRUE} in order to debug a test we
    are writing.  In this case, values for both \Rcode{solver} and
    \Rcode{verbose} will need to be specified explicitely.}

  What values should be used to fill in the blanks?  For the module
  lists, which are just vectors of names, the answer is clear:
  \begin{Rlisting}[4]
    steady_state_modules <- c(|\stringplaceholder{name of module being tested}|)
    derivative_modules <- c()
  \end{Rlisting}

  These may be defined globally, outside of any test.  The name of the
  module should exactly match the name as specified in the key of the
  entry for the module in \code{module_wrapper_creators}.

  In our example, we use

  \begin{Rexample}[4]
    steady_state_modules <- c("solar_zenith_angle_in_degrees")
    derivative_modules <- c()
  \end{Rexample}


  On the other hand, values for the module input parameters and for
  the initial state may potentially vary with each test.  The keys,
  however, will in most cases be uniform across tests.  For example,
  if the module inputs consist of invariant parameters $\ip_1$,
  $\ip_2$, \dots, $\ip_k$, varying parameters $\vp_1$, $\vp_2$, \dots,
  $\vp_m$, and initial state variables $\isv_1$, $\isv_2$, \dots,
  $\isv_n$, then we will be setting the corresponding function
  parameters to values of the following forms:
  \begin{Rlisting}[4]
    invariant_parameters <- list(ip_1 = ___, ip_2 = ___, ..., ip_k = ___)
    varying_parameters <- list(vp_1 = ___, vp_2 = ___, ..., vp_m = ___)
    initial_state <- list(isv_1 = ___, isv_2 = ___, ..., isv_n = ___)
  \end{Rlisting}

  As mentioned above, since we are setting up the most stripped-down
  of systems, these lists will be very short: we need to include a
  setting for each input parameter of the module being tested, and we
  need to include certain time-related settings.  In particular, the
  invariant parameter list must include a setting for
  \Rcode{timestep}, and the varying parameters must include either a
  setting for \Rcode{doy_dbl} or for both \Rcode{doy} and
  \Rcode{hour}.  The values assigned to the time-related variables is
  immaterial for the purposes of the test except in the case that one
  of them is also an input to the module being tested.  (The
  \code{solar_zenith_angle} module, for example, takes \Rcode{doy_dbl}
  as an input.)  It is best, however, to assign values that might make
  sense in the simulation of a ``real'' system.

  As for which list should include the module input variable values,
  this too is largely immaterial for the purposes of running the test.
  But again, to minimuze confusion, it is best to include the setting
  in the list that would make sense in a real system.  So, for
  example, if it is a parameter that normally varies over the course
  of time, then it doesn't make sense to assign it in the
  \Rcode{invariant_parameters} list, and if it varies over time but
  not in a way that can be predicted from rates of change, then it
  shouldn't be assigned within the \Rcode{initial_state}.

  For our example, we use settings as follows.

  \begin{Rexample}[4]
    invariant_parameters <- list(timestep = 1)
    varying_parameters <- list(doy_dbl = 1,
                               cosine_zenith_angle = |\placeholder{some value that will vary from test to test}|)
    initial_state <- list()
  \end{Rexample}

\item Write one or more tests.

  Each test will be a statement of the form
  \begin{Rlisting}[4]
    test_that(|\stringplaceholder{overall test description}|, {
      |\placeholder{one or more statements, including statements of the form \texttt{expect\_*(...)}}|
    })
  \end{Rlisting}
  More specifically, each test will generally set the parameter values
  that have not already been set globally and then call
  \Rcode{Gro_solver}:
  \begin{Rlisting}[4]
    result = Gro_solver(initial_state, invariant_parameters, varying_parameters, steady_state_modules, derivative_modules)
  \end{Rlisting}
  The subsequent statements may then test various aspects of \Rcode{result}.

  The heart of a \Rcode{testthat} test are the \emph{expectations}.
  These are assertions of some condition that should hold or some
  result that should be obtained from running the module code.  They
  take the form of a function call to any one of a number of functions
  whose names begin with the string \Rcode{expect_}.  We will be
  primarily concerned with two such functions:
  \Rcode{expect_equal(}\placeholder{actual value}\Rcode{,}
  \placeholder{expected value}\Rcode{)}, which tests that its two
  arguments are equal (give or take some small amount, which can be
  specfied explicitely by supplying a third argument of the form
  \Rcode{tolerance =} \placeholder{some small number}); and
  \Rcode{expect_true(}\placeholder{some boolean condition}\Rcode{)},
  which tests that some condition holds.  More about \Rcode{expect_}
  functions can be found in section 10.2.1 of
  \url{https://r-pkgs.org/tests.html}, and the full complement of
  \Rcode{expect_} functions is listed and documented at
  \url{https://cran.r-project.org/web/packages/testthat/testthat.pdf}.

  What should be tested?  Here are some possibilities:

  \begin{enumerate}

  \item Sample values that produce recognizable results.

    From elementary trignometry, we know, for example, that the angle
    between $0^\circ$ and $180^\circ$ having a cosine of $0.5$ is
    $60^\circ$.  We can test that this is the actual result obtained
    from our module with a simple test.  Assuming we have set the
    modules, invariant parameters, and initial state globally with
    \begin{Rexample}[6]
      steady_state_modules <- c("solar_zenith_angle_in_degrees")
      derivative_modules <- c()

      initial_state <- list()
      invariant_parameters <- list(timestep = 1)
    \end{Rexample}

    we can write our test as follows:\footnotemark

    \footnotetext{We make no attempt here to coordinate the input
      values for \Rcode{cosine_zenith_angle} and for
      \Rcode{doy_dbl}. While in general we prefer to use input
      values that might be associated with a realistic system, for
      the purposes of writing tests of a module, it may sometimes be
      more convenient not to do so.}

    \begin{Rexample}[6]
      test_that("When the cosine is 1/2, the angle is 60 degrees.", {
        varying_parameters <- list(doy_dbl = 1, cosine_zenith_angle = 0.5)
        result = Gro_solver(initial_state, invariant_parameters, varying_parameters, steady_state_modules, derivative_modules)
        expect_equal(result$zenith_angle_in_degrees, 60)
    \end{Rexample}

    Since we will likely call \Rcode{Gro_solver} in each test, we
    can write a helper function to factor the repetitious code out
    of our tests; for example,

    \begin{Rexample}[6]
      angle_from_cosine <- function(cza) {
        varying_parameters <- list(doy_dbl = 1, cosine_zenith_angle = cza)
        result = Gro_solver(initial_state, invariant_parameters, varying_parameters, steady_state_modules, derivative_modules)
        result$zenith_angle_in_degrees
      }
    \end{Rexample}

    Then our test becomes simply

    \begin{Rexample}[6]
      test_that("When the cosine is 1/2, the angle is 60 degrees.", {
        expect_equal(angle_from_cosine(0.5), 60)
      })
    \end{Rexample}


  \item Edge cases.

    It often makes sense to test module operation at the very
    limit of allowable values.  For the cosine of an angle, these
    limits are plus and minus one.\footnote{Note that zenith
      angles greater than $90^\circ$ correspond to the sun being
      below the horizon.}

    \begin{Rexample}[6]
      test_that("When the cosine is 1, the angle is 0 degrees", {
        angle <- angle_from_cosine(1)
        expect_equal(angle, 0)
      })

      test_that("When the cosine is -1, the angle is 180 degrees", {
        angle <- angle_from_cosine(-1)
        expect_equal(angle, 180)
      })
    \end{Rexample}

  \item It's a good idea to test how the module behaves when given
    input that is out of bounds.

    What should the module in our example do when given a value for
    the cosine that is greater than one or less than minus one?
    We'll assume it should return NaN (``not-a-number'').

    \begin{Rexample}[6]
      test_that("When the cosine is more than 1, the angle is not a number", {
        angle <- angle_from_cosine(1.000000001)
        expect_true(is.nan(angle))
      })

      test_that("When the cosine is less than -1, the angle is not a number", {
        angle <- angle_from_cosine(-1.000000001)
        expect_true(is.nan(angle))
      })
    \end{Rexample}

  \item Lastly, if you discover a bug in your module, it's a good
    idea to write a test that demonstrates the bug---a test that
    will pass once the bug is fixed and ensures it stays fixed if
    later changes are made.

  \end{enumerate}

  A listing of the complete test file is shown in appendix \ref{sza
    test file}.

\end{enumerate}


\subsubsection{Writing a unit test for a derivative module}

Again, it will suffice to set up a bare-bones system.  But this time,
we will set up a time sequence of length two or more since we want to
see how the derivative affects how the state changes over time.  For
the most basic tests of module functionality, we need only use a
sequence of two states.  Again, the state variables need only include
the input variables for the module being tested and the time-related
variables.\footnotemark

\footnotetext{In the case of a deriv module where some of the inputs
  correspond to outputs of steady-state modules, we have two choices
  with regard to testing: (1) include, as part of the test,
  steady-state modules that produce these required inputs; (2)
  artificially include values for these inputs as part of the varying
  parameters.  The latter option is the simplest and has the advantage
  of narrowing the scope of the test to the module we are most
  interested in testing.  But there may be cases where we want to test
  how two or more modules work in conjunction with one another.}

Here, we show how to test the heating degree days module.

\begin{enumerate}

\item Make a file for the test.

  \begin{Rexample}[4]
    test.heating_degree_days.R
  \end{Rexample}

\item Add a context statement.

  \begin{Rexample}[4]
    context('Test basic functioning of the deriv module "heading_degree_days".')
  \end{Rexample}

\item Define parameters for the \Rcode{Gro_solver} function.  Again,
  we will be assuming we call \Rcode{Gro_solver} with
  \begin{Rlisting}[4]
    Gro_solver(initial_state, invariant_parameters, varying_parameters,
               steady_state_modules, derivative_modules, solver, verbose)
  \end{Rlisting}

  The assignments for the two module vectors are more or less the
  reverse of what they were for the steady-state module test:
  \begin{Rlisting}[4]
    steady_state_modules <- c()
    derivative_modules <- c(|\stringplaceholder{name of module being tested}|)
  \end{Rlisting}

  For our example, this becomes
  \begin{Rexample}[4]
    steady_state_modules <- c()
    derivative_modules <- c("heating_degree_days")
  \end{Rexample}

  As for \Rcode{initial_state}, \Rcode{invariant_parameters}, and
  \Rcode{varying_parameters}, we may want to vary each of these from
  test to test.  We may also want to run tests using various solvers.

  For our example, we'll write a global helper function that makes this easy.
  
  \begin{Rexample}[4]
    calculate_heating_degree_days <- function(initial_value, time_vector, temperature_vector, threshold_temperature, timestep, solver) {
      initial_state <- list(heating_degree_days = initial_value)
      invariant_parameters <- list(base_temperature = threshold_temperature, timestep = timestep)
      varying_parameters <- list(doy_dbl = time_vector, temp = temperature_vector)

      result <- Gro_solver(initial_state, invariant_parameters, varying_parameters,
                           steady_state_modules, derivative_modules, solver)

      result$heating_degree_days[length(time_vector)]
    }
  \end{Rexample}

\item Write tests.

  A sample test file, with comments, for the
  \Rcode{heating_degree_days} module is shown in appendix \ref{hdd
    test file}.

\end{enumerate}

\subsubsection{Running the tests}

To run the tests you have just written, start an R session and make
sure both the \Rcode{BioCro} and the \Rcode{testthat} libraries are
loaded:

\begin{Rlisting}[2]
  library(BioCro)
  library(testthat)
\end{Rlisting}

Then, use the \Rcode{testthat::test_file} function, specifying the
path to the test file as argument.  (If you want to use a relative
path from the current directory, and you want to check which directory
\emph{is} the current directory, use the command \Rcode{getwd()}.)

For example, if we are in the package root directory, we can run the
two test files we have written with
\begin{Rexample}[2]
  test_file('tests/testthat/test.solar_zenith_angle_in_degrees.R')
\end{Rexample}
and
\begin{Rexample}[2]
  test_file('tests/testthat/test.heating_degree_days.R')
\end{Rexample}

If you wish to run \emph{all} of the \Rcode{testthat} tests, one way
to do this is to use the \Rcode{test_dir} function, giving the path to
the \Rcode{testthat} directory as argument.  Again, if we are in the
package root directory, we would do this:
\begin{Rlisting}[2]
  test_dir('tests/testthat')
\end{Rlisting}

If you have the \Rcode{devtools} package installed, running all tests
is even simpler.  Assuming both \Rcode{BioCro} and \Rcode{devtools}
have been loaded, simply do this:
\begin{Rlisting}[2]
  test()
\end{Rlisting}
If you use RStudio, one needn't even type: choosing ``Test Package''
from the Build menu, or simply using the keyboard-shortcut ``Ctrl/Cmd
+ Shift + T'' will suffice.  This method of running the tests has the
added advantage that a test producing a segmentation fault won't crash
the whole R session.\footnote{If you don't have the devtools package
  installed, the RStudio ``Test Package'' command will still work, but
  it won't do quite the same thing.  Instead of running all of the
  \Rcode{testthat} tests, it will run all of the \Rcode{.R} files in
  the \Rcode{tests} directory.}


\appendix

\section{Code listings}

\subsection{Full listing of solar-zenith-angle-in-degrees module} \label{sza module listing}

\lstinputlisting[style=C++style]{an_introduction_to_biocro/solar_zenith_angle_in_degrees.h}

\subsection{Full listing of heating-degree-days module} \label{hdd module listing}

\lstinputlisting[style=C++style]{an_introduction_to_biocro/heating_degree_days.h}

\subsection{Full listing of the unit-test file for solar-zenith-angle-in-degrees} \label{sza test file}

\lstinputlisting[style=Rstyle]{an_introduction_to_biocro/test.solar_zenith_angle_in_degrees.R}

\subsection{Full listing of the unit-test file for heating-degree-days} \label{hdd test file}

\lstinputlisting[style=Rstyle]{an_introduction_to_biocro/test.heating_degree_days.R}

\end{document}
